---
layout: post
title: End of History
tags: thoughts
---

History, it seems, is always ending today. It’s easy to imagine how much I have changed over the years. At 27 today, I have almost nothing in common with the 22-year old Akshay. Looking into the future, however, is quite a different story altogether.

I came across a good paper in the science magazine about a common illusion which might be related to programming. [Here](http://www.danielgilbert.com/Quoidbach et al 2013.pdf) is the link to the paper. If I were to summarize the paper in a paragraph, we have a fundamental misconception about our future selves and often underestimate how much our preferences, our values, our goals, and our personalities will change over time. This tendency to underestimate the magnitude of future change is the end of history illusion.

A good reason for this illusion is that most people(including myself) believe that their personalities are attractive, their values admirable, and their preferences wise, and having reached that exalted state, they may be reluctant to entertain the possibility of change. People also like to believe that they know themselves well, and the possibility of future change may threaten that belief. In short, we are motivated to think well of ourselves and to feel secure in that understanding, and the end of history illusion may help us accomplish this. The cognitive biases that affect us while looking forward into future and git back into the past don’t help, either.

I can think of quite a few ways how this might be affecting me as a programmer. Whenever I name my variables *l, ll, ideg, Vvec*, I am falling prey to the end of history illusion. A good example can be found [here](https://github.com/akshayKhot/Influence_Analysis_cpp/blob/master/dim.cpp). I might be thinking I have all the logic of the code figured out now, and will be able to keep the complexities in my head forever. At the same time, I am ignoring the future impact of the poorly named variables. I was browsing the above C++ repo recently and had a really tough time understanding what each piece of code was doing, and what I meant by each variable. The same illusion goes with poorly documented code and thinking that I will know it when I see it.